{% extends 'base.html' %}

{% block title %}{{ site.name }} Control Panel{% endblock %}

{% block extra_css %}
{% load static %}
<link rel="stylesheet" href="{% static 'css/ha-style.css' %}">
<style>
  /* Additional inline styles */
  .ha-interface {
    display: flex;
    height: calc(100vh - 100px);
  }
  .sidebar {
    width: 250px;
    background: #f5f5f5;
    padding: 1rem;
    overflow-y: auto;
    border-right: 1px solid rgba(0, 0, 0, 0.12);
  }
  .main-panel {
    flex: 1;
    padding: 1rem;
    overflow-y: auto;
  }
  .interface-header {
    background-color: var(--primary-color);
    color: white;
    padding: 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .connection-indicator {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 0.5rem;
    vertical-align: middle;
  }
  .connected { background: #4CAF50; }
  .disconnected { background: #F44336; }
  .domain-section {
    margin-bottom: 1.5rem;
  }
  .domain-section h3 {
    color: var(--primary-color);
    border-bottom: 1px solid rgba(0, 0, 0, 0.12);
    padding-bottom: 0.5rem;
    margin-bottom: 0.5rem;
  }
  .entity-item {
    padding: 0.5rem;
    cursor: pointer;
    border-radius: 4px;
    margin-bottom: 0.2rem;
  }
  .entity-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }
  .entity-item.active {
    background-color: rgba(3, 169, 244, 0.1);
    font-weight: 500;
  }
  .loading {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary-color);
  }
  .placeholder {
    text-align: center;
    padding: 4rem 2rem;
    color: var(--text-secondary-color);
  }
  #connection-status {
    font-size: 0.9rem;
  }
  .attributes-list {
    margin-top: 0.5rem;
    margin-bottom: 1rem;
    padding-left: 1.5rem;
  }
  .entity-controls {
    margin-top: 1rem;
    display: flex;
    gap: 0.5rem;
  }
  .ha-button {
    background-color: var(--primary-color);
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
  }
  .ha-button:hover {
    background-color: var(--primary-color-dark, #0288d1);
  }
</style>
{% endblock %}

{% block content %}
<header class="interface-header">
  <h1>
    <span id="connection-indicator" class="connection-indicator disconnected"></span>
    {{ site.name }}
  </h1>
  <div id="connection-status">Connecting...</div>
</header>

<div class="ha-interface">
  <div class="sidebar">
    <h2>Entities</h2>
    <div class="search-box">
      <input type="text" id="entity-search" placeholder="Search entities..." class="search-input">
    </div>
    <div id="entity-list" class="entity-list">
      <div class="loading">Loading entities...</div>
    </div>
  </div>
  
  <div class="main-panel">
    <div id="entity-details">
      <div class="placeholder">Select an entity from the sidebar to view details and controls</div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{% static 'js/vendor/haws.umd.js' %}"></script>
<script src="{% static 'js/vendor/lodash.min.js' %}"></script>
<script type="module" src="{% static 'js/ha-components.js' %}"></script>
<script>
  // Configuration
  const siteId = "{{ site.id }}";
  const wsUrl = `ws://${window.location.host}/ws/ha/frontend/${siteId}/`;
  let socket = null;
  let messageId = 1;
  let eventSubscriptions = {};
  
  // DOM elements
  const connectionIndicator = document.getElementById('connection-indicator');
  const connectionStatus = document.getElementById('connection-status');
  const entityList = document.getElementById('entity-list');
  const entityDetails = document.getElementById('entity-details');
  
  // Connect to WebSocket and set up handlers
  function connectWebSocket() {
    if (socket && socket.readyState === WebSocket.OPEN) {
      return socket;
    }
    
    console.log(`Connecting to WebSocket at ${wsUrl}`);
    socket = new WebSocket(wsUrl);
    
    socket.addEventListener('open', () => {
      console.log("WebSocket connection established");
      connectionStatus.textContent = "Connected to server";
      
      // Request entity states immediately after connection
      getEntityStates();
      
      // Subscribe to state changes
      subscribeToEvents("state_changed");
    });
    
    socket.addEventListener('message', (event) => {
      console.log("Received WebSocket message:", event.data);
      try {
        const message = JSON.parse(event.data);
        
        // Handle auth_ok message
        if (message.type === "auth_ok") {
          updateConnectionStatus(message.ha_connected);
        }
        
        // Handle entity states response
        if (message.type === "result" && message.id && message.result) {
          handleResultMessage(message);
        }
        
        // Handle state changed events
        if (message.type === "state_changed") {
          updateEntityState(message.data.entity_id, message.data.new_state);
        }
        
        // Handle event messages
        if (message.type === "event") {
          handleEventMessage(message);
        }
      } catch (error) {
        console.error("Error processing message:", error);
      }
    });
    
    socket.addEventListener('close', () => {
      console.log("WebSocket connection closed");
      connectionStatus.textContent = "Disconnected";
      connectionIndicator.classList.remove('connected');
      connectionIndicator.classList.add('disconnected');
      
      // Clear event subscriptions
      eventSubscriptions = {};
      
      // Attempt to reconnect after delay
      setTimeout(connectWebSocket, 3000);
    });
    
    socket.addEventListener('error', (error) => {
      console.error("WebSocket error:", error);
      connectionStatus.textContent = "Connection error";
    });
    
    return socket;
  }
  
  // Handle result messages based on context
  function handleResultMessage(message) {
    const id = message.id;
    const result = message.result;
    
    // Check what type of result this is based on message ID
    if (id.toString().startsWith('get_states')) {
      displayEntities(result);
    }
    else if (id.toString().startsWith('subscribe_')) {
      const eventType = id.toString().replace('subscribe_', '');
      eventSubscriptions[eventType] = true;
      console.log(`Subscribed to ${eventType} events`);
    }
  }
  
  // Handle event messages
  function handleEventMessage(message) {
    const eventType = message.event.event_type;
    
    if (eventType === 'state_changed') {
      const entityId = message.event.data.entity_id;
      const newState = message.event.data.new_state;
      updateEntityState(entityId, newState);
    }
  }
  
  // Send a message to the WebSocket
  function sendMessage(message) {
    if (!socket || socket.readyState !== WebSocket.OPEN) {
      socket = connectWebSocket();
      // Wait for connection to be established
      setTimeout(() => sendMessage(message), 1000);
      return;
    }
    
    // Add ID if not present
    if (!message.id) {
      message.id = `${message.type}_${messageId++}`;
    }
    
    console.log("Sending message:", message);
    socket.send(JSON.stringify(message));
    return message.id;
  }
  
  // Subscribe to Home Assistant events
  function subscribeToEvents(eventType) {
    if (eventSubscriptions[eventType]) {
      return; // Already subscribed
    }
    
    sendMessage({
      type: "subscribe_events",
      event_type: eventType,
      id: `subscribe_${eventType}`
    });
  }
  
  // Request entity states
  function getEntityStates() {
    sendMessage({ type: "get_states", id: "get_states_1" });
  }
  
  // Call a Home Assistant service
  function callService(domain, service, entityId) {
    sendMessage({
      type: "call_service",
      domain: domain,
      service: service,
      service_data: { entity_id: entityId }
    });
  }
  
  // Update connection status UI
  function updateConnectionStatus(connected) {
    if (connected) {
      connectionIndicator.classList.remove('disconnected');
      connectionIndicator.classList.add('connected');
      connectionStatus.textContent = "Connected to Home Assistant";
    } else {
      connectionIndicator.classList.remove('connected');
      connectionIndicator.classList.add('disconnected');
      connectionStatus.textContent = "Home Assistant not connected";
    }
  }
  
  // Display entities in the sidebar
  function displayEntities(entities) {
    console.log("Displaying entities:", entities);
    entityList.innerHTML = '';
    
    if (!entities || entities.length === 0) {
      entityList.innerHTML = '<div class="loading">No entities available</div>';
      return;
    }
    
    // Group entities by domain
    const domains = {};
    entities.forEach(entity => {
      const domain = entity.entity_id.split('.')[0];
      if (!domains[domain]) domains[domain] = [];
      domains[domain].push(entity);
    });
    
    // Create domain sections
    Object.entries(domains).forEach(([domain, domainEntities]) => {
      const section = document.createElement('div');
      section.className = 'domain-section';
      section.setAttribute('data-domain', domain);
      
      const title = document.createElement('h3');
      title.textContent = domain.charAt(0).toUpperCase() + domain.slice(1);
      section.appendChild(title);
      
      // Create entity items
      domainEntities.forEach(entity => {
        const item = document.createElement('div');
        item.className = 'entity-item';
        item.setAttribute('data-entity-id', entity.entity_id);
        item.textContent = entity.attributes?.friendly_name || entity.entity_id;
        
        // Add click event to show entity details
        item.addEventListener('click', () => {
          // Remove active class from all entities
          document.querySelectorAll('.entity-item.active').forEach(el => {
            el.classList.remove('active');
          });
          
          // Add active class to clicked entity
          item.classList.add('active');
          
          // Show entity details
          showEntityDetails(entity.entity_id, entity);
        });
        
        section.appendChild(item);
      });
      
      entityList.appendChild(section);
    });
    
    // Check if search box has input and filter accordingly
    const searchBox = document.getElementById('entity-search');
    if (searchBox && searchBox.value) {
      filterEntities(searchBox.value);
    }
  }
  
  // Filter entities based on search input
  function filterEntities(searchTerm) {
    searchTerm = searchTerm.toLowerCase();
    
    // Filter entity items
    document.querySelectorAll('.entity-item').forEach(item => {
      const text = item.textContent.toLowerCase();
      const entityId = item.getAttribute('data-entity-id').toLowerCase();
      
      if (text.includes(searchTerm) || entityId.includes(searchTerm)) {
        item.style.display = '';
      } else {
        item.style.display = 'none';
      }
    });
    
    // Hide domain sections with no visible entities
    document.querySelectorAll('.domain-section').forEach(section => {
      const hasVisibleEntities = Array.from(
        section.querySelectorAll('.entity-item')
      ).some(item => item.style.display !== 'none');
      
      section.style.display = hasVisibleEntities ? '' : 'none';
    });
  }
  
  // Update entity state when it changes
  function updateEntityState(entityId, newState) {
    // Update entity in sidebar
    const entityItem = document.querySelector(`.entity-item[data-entity-id="${entityId}"]`);
    if (entityItem) {
      entityItem.textContent = newState.attributes?.friendly_name || entityId;
    }
    
    // If this entity is currently selected, update its details
    const activeEntity = document.querySelector('.entity-item.active');
    if (activeEntity && activeEntity.getAttribute('data-entity-id') === entityId) {
      showEntityDetails(entityId, newState);
    }
  }
  
  // Display entity details in the main panel
  function showEntityDetails(entityId, entity) {
    console.log("Showing details for entity:", entityId, entity);
    entityDetails.innerHTML = '';
    entityDetails.setAttribute('data-entity-id', entityId);
    
    const card = document.createElement('div');
    card.className = 'ha-card';
    
    const header = document.createElement('div');
    header.className = 'card-header';
    header.textContent = entity.attributes?.friendly_name || entityId;
    card.appendChild(header);
    
    const content = document.createElement('div');
    content.className = 'card-content';
    
    // State section
    const stateSection = document.createElement('div');
    stateSection.className = 'state-section';
    stateSection.innerHTML = `<strong>State:</strong> ${entity.state}`;
    
    // Add state-specific formatting
    if (['on', 'off'].includes(entity.state)) {
      const stateSpan = document.createElement('span');
      stateSpan.className = `state-badge state-${entity.state}`;
      stateSpan.textContent = entity.state;
      
      stateSection.innerHTML = `<strong>State:</strong> `;
      stateSection.appendChild(stateSpan);
    }
    
    content.appendChild(stateSection);
    
    // Last updated section
    if (entity.last_updated) {
      const lastUpdated = document.createElement('div');
      lastUpdated.className = 'last-updated';
      lastUpdated.innerHTML = `<strong>Last Updated:</strong> ${formatDateTime(entity.last_updated)}`;
      content.appendChild(lastUpdated);
    }
    
    // Attributes section (limited to avoid cluttering)
    if (entity.attributes && Object.keys(entity.attributes).length > 0) {
      const attrSection = document.createElement('div');
      attrSection.className = 'attributes-section';
      attrSection.innerHTML = '<strong>Attributes:</strong>';
      
      const attrList = document.createElement('ul');
      attrList.className = 'attributes-list';
      
      // Filter out some common attributes that aren't as useful to show
      const filteredKeys = Object.keys(entity.attributes)
        .filter(key => !['friendly_name', 'icon', 'entity_picture', 'supported_features'].includes(key))
        .slice(0, 5);  // Limit to first 5 attributes
      
      filteredKeys.forEach(key => {
        const value = entity.attributes[key];
        const item = document.createElement('li');
        
        // Format the value based on type
        let displayValue;
        if (typeof value === 'object') {
          displayValue = JSON.stringify(value).substring(0, 50);
          if (JSON.stringify(value).length > 50) {
            displayValue += '...';
          }
        } else {
          displayValue = value;
        }
        
        item.textContent = `${key}: ${displayValue}`;
        attrList.appendChild(item);
      });
      
      if (filteredKeys.length > 0) {
        attrSection.appendChild(attrList);
        content.appendChild(attrSection);
      }
    }
    
    // Controls section based on entity domain
    const domain = entityId.split('.')[0];
    
    if (['light', 'switch', 'input_boolean', 'automation', 'script'].includes(domain)) {
      const controlsSection = document.createElement('div');
      controlsSection.className = 'entity-controls';
      
      // Toggle button for lights, switches, input_booleans
      if (['light', 'switch', 'input_boolean'].includes(domain)) {
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'ha-button toggle-btn';
        toggleBtn.textContent = entity.state === 'on' ? 'Turn Off' : 'Turn On';
        toggleBtn.addEventListener('click', () => {
          const service = entity.state === 'on' ? 'turn_off' : 'turn_on';
          callService(domain, service, entityId);
          
          // Optimistic UI update
          const newState = JSON.parse(JSON.stringify(entity));
          newState.state = entity.state === 'on' ? 'off' : 'on';
          setTimeout(() => showEntityDetails(entityId, newState), 100);
        });
        
        controlsSection.appendChild(toggleBtn);
      }
      
      // Run button for scripts and automations
      if (['script', 'automation'].includes(domain)) {
        const runBtn = document.createElement('button');
        runBtn.className = 'ha-button run-btn';
        runBtn.textContent = domain === 'script' ? 'Run Script' : 'Trigger';
        runBtn.addEventListener('click', () => {
          callService(domain, 'turn_on', entityId);
        });
        
        controlsSection.appendChild(runBtn);
      }
      
      content.appendChild(controlsSection);
    }
    
    card.appendChild(content);
    entityDetails.appendChild(card);
  }
  
  // Format date/time for display
  function formatDateTime(isoString) {
    if (!isoString) return 'Unknown';
    
    try {
      const date = new Date(isoString);
      return date.toLocaleString();
    } catch (e) {
      return isoString;
    }
  }
  
  // Initialize when the page loads
  document.addEventListener('DOMContentLoaded', () => {
    console.log("Page loaded, connecting to WebSocket");
    connectWebSocket();
    
    // Add search functionality
    const searchBox = document.getElementById('entity-search');
    if (searchBox) {
      searchBox.addEventListener('input', (event) => {
        filterEntities(event.target.value);
      });
    }
    
    // Add a refresh button
    const refreshBtn = document.createElement('button');
    refreshBtn.textContent = 'Refresh Entities';
    refreshBtn.className = 'ha-button';
    refreshBtn.style.marginLeft = '1rem';
    refreshBtn.addEventListener('click', () => {
      getEntityStates();
    });
    document.querySelector('.interface-header h1').appendChild(refreshBtn);
  });
</script>
{% endblock %}